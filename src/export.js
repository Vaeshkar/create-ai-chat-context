const fs = require("fs-extra");
const path = require("path");
const chalk = require("chalk");
const ora = require("ora");

/**
 * Export knowledge base in various formats
 */
async function exportKnowledgeBase(options = {}) {
  const cwd = process.cwd();
  const aiDir = path.join(cwd, ".ai");
  const format = options.format || "markdown";
  const output = options.output || `knowledge-base.${getExtension(format)}`;

  // Check if .ai directory exists
  if (!(await fs.pathExists(aiDir))) {
    console.log(chalk.red("\n❌ No .ai/ directory found.\n"));
    console.log(chalk.gray("   Run: npx create-ai-chat-context init\n"));
    return;
  }

  const spinner = ora(`Exporting knowledge base as ${format}...`).start();

  try {
    const outputPath = path.join(cwd, output);

    // Check if output file already exists
    if ((await fs.pathExists(outputPath)) && !options.force) {
      spinner.fail("Export file already exists");
      console.log(
        chalk.yellow(
          `\n⚠️  ${output} already exists. Use --force to overwrite.\n`
        )
      );
      return;
    }

    switch (format.toLowerCase()) {
      case "markdown":
      case "md":
        await exportMarkdown(aiDir, outputPath);
        break;
      case "json":
        await exportJSON(aiDir, outputPath);
        break;
      case "html":
        await exportHTML(aiDir, outputPath);
        break;
      default:
        spinner.fail("Unknown format");
        console.log(chalk.red(`\n❌ Unknown format: ${format}\n`));
        console.log(chalk.gray("   Supported formats: markdown, json, html\n"));
        return;
    }

    spinner.succeed(`Exported to ${output}`);

    console.log(chalk.green("\n✅ Knowledge base exported!\n"));
    console.log(chalk.bold("📄 Output:\n"));
    console.log(`   File: ${chalk.cyan(output)}`);
    console.log(`   Format: ${chalk.cyan(format)}`);
    console.log();

    console.log(chalk.bold("💡 What to do with it:\n"));
    if (format === "markdown" || format === "md") {
      console.log("   • Share with team members");
      console.log("   • Create backup");
      console.log("   • Convert to other formats");
      console.log("   • Read offline");
    } else if (format === "json") {
      console.log("   • Import into other tools");
      console.log("   • Process programmatically");
      console.log("   • Create backups");
    } else if (format === "html") {
      console.log("   • View in browser");
      console.log("   • Share as webpage");
      console.log("   • Print as document");
    }
    console.log();
  } catch (error) {
    spinner.fail("Failed to export");
    throw error;
  }
}

/**
 * Export as Markdown
 */
async function exportMarkdown(aiDir, outputPath) {
  const files = [
    "README.md",
    "architecture.md",
    "technical-decisions.md",
    "conversation-log.md",
    "known-issues.md",
    "next-steps.md",
    "SETUP_GUIDE.md",
    "TOKEN_MANAGEMENT.md",
  ];

  let content = `# Knowledge Base Export\n\n`;
  content += `**Exported:** ${new Date().toISOString()}\n\n`;
  content += `**Generated by:** [create-ai-chat-context](https://www.npmjs.com/package/create-ai-chat-context)\n\n`;
  content += `---\n\n`;

  for (const file of files) {
    const filePath = path.join(aiDir, file);
    if (await fs.pathExists(filePath)) {
      const fileContent = await fs.readFile(filePath, "utf-8");
      content += `# ${file.replace(".md", "")}\n\n`;
      content += fileContent;
      content += `\n\n---\n\n`;
    }
  }

  await fs.writeFile(outputPath, content, "utf-8");
}

/**
 * Export as JSON
 */
async function exportJSON(aiDir, outputPath) {
  const files = [
    "README.md",
    "architecture.md",
    "technical-decisions.md",
    "conversation-log.md",
    "known-issues.md",
    "next-steps.md",
    "SETUP_GUIDE.md",
    "TOKEN_MANAGEMENT.md",
  ];

  const data = {
    exported: new Date().toISOString(),
    generator: "create-ai-chat-context",
    version: "0.5.0",
    files: {},
  };

  for (const file of files) {
    const filePath = path.join(aiDir, file);
    if (await fs.pathExists(filePath)) {
      const content = await fs.readFile(filePath, "utf-8");
      const stats = await fs.stat(filePath);
      
      data.files[file] = {
        content,
        size: stats.size,
        modified: stats.mtime.toISOString(),
        lines: content.split("\n").length,
        words: content.split(/\s+/).filter((w) => w.length > 0).length,
      };
    }
  }

  await fs.writeFile(outputPath, JSON.stringify(data, null, 2), "utf-8");
}

/**
 * Export as HTML
 */
async function exportHTML(aiDir, outputPath) {
  const files = [
    "README.md",
    "architecture.md",
    "technical-decisions.md",
    "conversation-log.md",
    "known-issues.md",
    "next-steps.md",
    "SETUP_GUIDE.md",
    "TOKEN_MANAGEMENT.md",
  ];

  let html = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Knowledge Base Export</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      line-height: 1.6;
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
      color: #333;
    }
    h1 { color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 10px; }
    h2 { color: #34495e; margin-top: 30px; }
    h3 { color: #7f8c8d; }
    pre { background: #f4f4f4; padding: 15px; border-radius: 5px; overflow-x: auto; }
    code { background: #f4f4f4; padding: 2px 6px; border-radius: 3px; }
    .file-section { margin: 40px 0; padding: 20px; border: 1px solid #ddd; border-radius: 5px; }
    .file-title { background: #3498db; color: white; padding: 10px; margin: -20px -20px 20px -20px; border-radius: 5px 5px 0 0; }
    .metadata { color: #7f8c8d; font-size: 0.9em; margin-bottom: 20px; }
  </style>
</head>
<body>
  <h1>📚 Knowledge Base Export</h1>
  <div class="metadata">
    <p><strong>Exported:</strong> ${new Date().toLocaleString()}</p>
    <p><strong>Generated by:</strong> <a href="https://www.npmjs.com/package/create-ai-chat-context">create-ai-chat-context</a></p>
  </div>
  <hr>
`;

  for (const file of files) {
    const filePath = path.join(aiDir, file);
    if (await fs.pathExists(filePath)) {
      const content = await fs.readFile(filePath, "utf-8");
      const htmlContent = markdownToSimpleHTML(content);
      
      html += `
  <div class="file-section">
    <div class="file-title">📄 ${file}</div>
    ${htmlContent}
  </div>
`;
    }
  }

  html += `
</body>
</html>`;

  await fs.writeFile(outputPath, html, "utf-8");
}

/**
 * Simple markdown to HTML converter
 */
function markdownToSimpleHTML(markdown) {
  let html = markdown;
  
  // Headers
  html = html.replace(/^### (.*$)/gim, "<h3>$1</h3>");
  html = html.replace(/^## (.*$)/gim, "<h2>$1</h2>");
  html = html.replace(/^# (.*$)/gim, "<h1>$1</h1>");
  
  // Bold
  html = html.replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>");
  
  // Italic
  html = html.replace(/\*(.*?)\*/g, "<em>$1</em>");
  
  // Code blocks
  html = html.replace(/```(.*?)```/gs, "<pre><code>$1</code></pre>");
  
  // Inline code
  html = html.replace(/`(.*?)`/g, "<code>$1</code>");
  
  // Links
  html = html.replace(/\[(.*?)\]\((.*?)\)/g, '<a href="$2">$1</a>');
  
  // Line breaks
  html = html.replace(/\n\n/g, "</p><p>");
  html = "<p>" + html + "</p>";
  
  return html;
}

/**
 * Get file extension for format
 */
function getExtension(format) {
  switch (format.toLowerCase()) {
    case "markdown":
    case "md":
      return "md";
    case "json":
      return "json";
    case "html":
      return "html";
    default:
      return "txt";
  }
}

module.exports = {
  exportKnowledgeBase,
};

