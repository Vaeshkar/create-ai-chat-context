const fs = require("fs-extra");
const path = require("path");
const chalk = require("chalk");
const ora = require("ora");

/**
 * Generate .cursorrules file for Cursor integration
 */
async function generateCursorRules(options = {}) {
  const cwd = process.cwd();
  const aiDir = path.join(cwd, ".ai");
  const cursorRulesPath = path.join(cwd, ".cursorrules");

  // Check if .ai directory exists
  if (!(await fs.pathExists(aiDir))) {
    console.log(chalk.red("\n❌ No .ai/ directory found.\n"));
    console.log(chalk.gray("   Run: npx create-ai-chat-context init\n"));
    return;
  }

  const spinner = ora("Generating .cursorrules file...").start();

  try {
    // Check if .cursorrules already exists
    if ((await fs.pathExists(cursorRulesPath)) && !options.force) {
      spinner.fail(".cursorrules already exists");
      console.log(
        chalk.yellow(
          "\n⚠️  .cursorrules file already exists. Use --force to overwrite.\n"
        )
      );
      return;
    }

    // Generate the rules content
    const rulesContent = generateRulesContent();

    // Write the file
    await fs.writeFile(cursorRulesPath, rulesContent, "utf-8");

    spinner.succeed(".cursorrules file created");

    console.log(chalk.green("\n✅ Cursor integration configured!\n"));
    console.log(chalk.bold("📝 What this does:\n"));
    console.log("  • Cursor will automatically read your .ai/ knowledge base");
    console.log("  • Context is loaded at the start of every chat");
    console.log("  • No need to manually prompt Cursor to read files");
    console.log();

    console.log(chalk.bold("🚀 Next steps:\n"));
    console.log("1. Restart Cursor (if it's running)");
    console.log("2. Start a new chat in Cursor");
    console.log("3. Cursor will automatically have your project context!");
    console.log();

    console.log(chalk.bold("💡 Tips:\n"));
    console.log("  • Update .ai/ files regularly for best results");
    console.log(
      "  • Use 'npx create-ai-chat-context chat-finish' after each chat session"
    );
    console.log(
      "  • Run 'npx create-ai-chat-context check' to monitor token usage"
    );
    console.log();

    // Add to .gitignore if it exists
    await addToGitignore(cwd, ".cursorrules");
  } catch (error) {
    spinner.fail("Failed to generate .cursorrules");
    throw error;
  }
}

/**
 * Generate the content for .cursorrules file
 */
function generateRulesContent() {
  return `# Cursor AI Rules
# Auto-generated by create-ai-chat-context
# https://www.npmjs.com/package/create-ai-chat-context

# IMPORTANT: Read project context before starting work
# This ensures you have full knowledge of the project architecture, decisions, and history.

## 📚 REQUIRED READING (Read these files first):

1. **\`.ai-instructions\`** - Start here! This is your entry point.
   - Contains workflow instructions
   - Links to all other knowledge base files
   - Explains how to use the system

2. **\`.ai/README.md\`** - Overview of the knowledge base system

3. **\`.ai/architecture.md\`** - System architecture and design
   - How the project is structured
   - Key components and their relationships
   - Technology stack and choices

4. **\`.ai/technical-decisions.md\`** - Why we made certain choices
   - Important technical decisions
   - Rationale behind each decision
   - Trade-offs considered

5. **\`.ai/conversation-log.md\`** - Chat history and progress
   - What has been done in previous sessions
   - Key decisions made during development
   - Current state of the project

6. **\`.ai/known-issues.md\`** - Current problems and workarounds
   - Known bugs and limitations
   - Temporary solutions
   - Things to avoid

7. **\`.ai/next-steps.md\`** - Planned work and roadmap
   - What needs to be done next
   - Priority order
   - Future improvements

## 🎯 WORKFLOW:

### At START of conversation:
1. Read all the files listed above (they're in the .ai/ directory)
2. Check token usage by counting conversation log entries
3. If > 30 entries, tell user: "📊 Your conversation log has [X] entries. Run \`npx create-ai-chat-context check\` to see token usage."
4. If > 50 entries, tell user: "🚨 Your conversation log has [X] entries (large!). Consider running: \`npx create-ai-chat-context archive --keep 10\`"
5. Understand the current state before making suggestions

### During conversation:
- Reference the knowledge base when making decisions
- Follow established patterns and conventions
- Respect technical decisions already made
- Check known-issues before suggesting solutions

### At END of conversation:
- Remind user to update the conversation log
- Suggest: "Run \`npx create-ai-chat-context chat-finish\` to automatically update all .ai/ files"
- This will analyze git changes and update conversation-log.md, technical-decisions.md, and more

## 📊 TOKEN MANAGEMENT:

- Be aware of token usage
- Suggest archiving if conversation log is large
- Recommend: \`npx create-ai-chat-context check\` to see usage
- Recommend: \`npx create-ai-chat-context archive --keep 10\` if needed

## ✅ BENEFITS:

- You have full project context from the start
- No need to re-explain architecture or decisions
- Consistent suggestions across sessions
- Better code that follows project patterns
- Faster development with less back-and-forth

## 🔄 KEEPING CONTEXT UPDATED:

The user should update the knowledge base regularly:
- After each chat session (conversation log)
- When making important decisions (technical-decisions.md)
- When architecture changes (architecture.md)
- When discovering issues (known-issues.md)

Remind them to do this at the end of each session!

---

**Note:** This file was auto-generated. To regenerate:
\`\`\`bash
npx create-ai-chat-context cursor --force
\`\`\`

To update your knowledge base:
\`\`\`bash
npx create-ai-chat-context log      # Add conversation entry
npx create-ai-chat-context validate # Check quality
npx create-ai-chat-context check    # Check token usage
\`\`\`
`;
}

/**
 * Add entry to .gitignore if it doesn't exist
 */
async function addToGitignore(cwd, entry) {
  const gitignorePath = path.join(cwd, ".gitignore");

  if (!(await fs.pathExists(gitignorePath))) {
    return;
  }

  const content = await fs.readFile(gitignorePath, "utf-8");

  // Check if entry already exists
  if (content.includes(entry)) {
    return;
  }

  // Add entry
  const newContent = content.trim() + `\n\n# Cursor AI rules\n${entry}\n`;
  await fs.writeFile(gitignorePath, newContent, "utf-8");
}

module.exports = {
  generateCursorRules,
};
